use chrono::prelude::Local;
use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use windows::{
    core::*,
    Data::Xml::Dom::{IXmlNode, XmlDocument, XmlText},
    Foundation::{Collections::IVector, Uri},
    Web::Syndication::{SyndicationClient, SyndicationFeed, SyndicationItem},
    UI::Notifications::{ToastNotification, ToastNotificationManager, ToastTemplateType},
};

// Modify this search string to math the product you are looking for
static SEARCH_STRING: &str = "(US): RPi 5 - 8GB RAM";

// Use the Microsoft AUMID for powershell, or terminal for notifications to
// function properly
// To find the AUMID of your powershell or terminal instance, run the following
// in powershell:
// Get-StartApps powershell
static AUMID: &str = "Microsoft.AutoGenerated.{A49227EA-5AF0-D494-A3F1-0918A278ED71}";

pub fn run() -> Result<()> {
    // Setup the RSS feed reader
    let mut prev_feeds: HashSet<String> = HashSet::new();
    let client = SyndicationClient::new()?;
    client.SetRequestHeader(
        h!("User-Agent"),
        h!("Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)"),
    )?;

    loop {
        // Get available feeds
        match check_syndication(&client) {
            Ok(syndication) => {
                let new_feeds = remove_duplicates(parse_syndication(syndication), &mut prev_feeds);
                for feed in new_feeds {
                    if feed.contains(SEARCH_STRING) {
                        // Stock found
                        notify(&feed).expect("Failed to send notification");
                    }
                    // Allow time for async toast creation to complete
                    thread::sleep(Duration::from_millis(500));
                }
            }
            Err(_e) => {
                println!("Check_feed failed. Retrying in 5 minutes")
            }
        };

        // Update the stdout to show program is not idle/hung
        println!("Sleeping for 5 minutes");
        // Only check every 5 minutes to avoid spamming the RSS feed
        thread::sleep(Duration::from_secs(300));
    }
}

fn check_syndication(client: &SyndicationClient) -> Result<SyndicationFeed> {
    let uri = Uri::CreateUri(h!("https://rpilocator.com/feed"))?;
    client.RetrieveFeedAsync(&uri)?.get()
}

fn parse_syndication(syndication_feed: SyndicationFeed) -> Vec<String> {
    let feed_items: IVector<SyndicationItem> = syndication_feed.Items().unwrap();

    feed_items
        .into_iter()
        .map(|item| item.Title().unwrap().Text().unwrap().to_string())
        .collect::<Vec<String>>()
}

fn remove_duplicates(incoming_feeds: Vec<String>, prev_feeds: &mut HashSet<String>) -> Vec<String> {
    let mut new_feeds: Vec<String> = Vec::new();
    let now = Local::now();
    for item in incoming_feeds {
        if !prev_feeds.contains(&item) {
            println!("{} - {}", now.format("%Y-%m-%d %H:%M:%S"), item);
            new_feeds.push(item.clone());
            prev_feeds.insert(item.clone());
        }
    }
    new_feeds
}

fn notify(feed: &String) -> Result<()> {
    if feed.contains(SEARCH_STRING) {
        // New feed detects search string. Send toast notification
        let notification = {
            let toast_xml: XmlDocument =
                ToastNotificationManager::GetTemplateContent(ToastTemplateType::ToastText01)?;
            let text_node: IXmlNode = toast_xml.GetElementsByTagName(h!("text"))?.Item(0)?;
            let text: XmlText = toast_xml.CreateTextNode(&HSTRING::from(feed))?;
            text_node.AppendChild(&text)?;
            ToastNotification::CreateToastNotification(&toast_xml)?
        };

        // Send the toast notification
        ToastNotificationManager::GetDefault()?
            .CreateToastNotifierWithId(&HSTRING::from(AUMID))?
            .Show(&notification)?;
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use windows::Data::Xml::Dom::XmlLoadSettings;
    pub struct XmlDoc {
        mock_xml: XmlDocument,
    }

    impl Default for XmlDoc {
        fn default() -> Self {
            let xml = String::from(
                "\
                <?xml version=\"1.0\" encoding=\"UTF-8\" ?><rss version=\"2.0\">\
                    <channel>\
                        <title>Mock Channel Title</title>\
                        <link>https://mockchannellink.com</link>\
                        <description>Mock Channel Description</description>\
                        <lastbuilddate>Fri, 08 Dec 2023 01:00:00 GMT</lastbuilddate>\
                        <item>\
                            <title>Mock Item Title</title>\
                            <description>Mock Item Description.</description>\
                            <link>https://mockitemlink.com</link>\
                            <guid ispermalink=\"false\">846c1690-b4ad-479a-95e3-2ca5ed4dfdbd</guid>\
                            <pubdate>Fri, 08 Dec 2023 01:00:00 GMT</pubdate>\
                        </item>\
                    </channel>\
                </rss>\
                ",
            );

            let xml_opts = XmlLoadSettings::new().expect("Opts creation failed");
            xml_opts
                .SetValidateOnParse(true)
                .expect("Set validate option failed");

            let mock_xml: XmlDocument = XmlDocument::new().expect("New XmlDoc::new failed");
            match mock_xml.LoadXmlWithSettings(&HSTRING::from(xml), &xml_opts) {
                Ok(doc) => doc,
                Err(e) => {
                    println!("LoadXml failed: {}", e.code());
                }
            };
            Self { mock_xml }
        }
    }

    #[test]
    fn verify_parse_syndication() {
        let xml_doc = XmlDoc::default().mock_xml;

        let mock_feed = SyndicationFeed::new().expect("New SyndicationFeed failed");
        mock_feed
            .LoadFromXml(&xml_doc)
            .expect("Load from xml failed");
        let output = parse_syndication(mock_feed);
        assert_eq!(output.len(), 1);
    }
}

