use chrono::prelude::Local;
use std::collections::HashSet;
use std::thread;
use std::time::Duration;
use windows::{
    core::*,
    Data::Xml::Dom::{IXmlNode, XmlDocument, XmlText},
    Foundation::{Collections::IVector, Uri},
    Web::Syndication::{SyndicationClient, SyndicationItem},
    UI::Notifications::{ToastNotification, ToastNotificationManager, ToastTemplateType},
};

// Modify this search string to math the product you are looking for
static SEARCH_STRING: &str = "(US): RPi 5 - 8GB RAM";

// Use the Microsoft AUMID for powershell, or terminal for notifications to
// function properly
// To find the AUMID of your powershell or terminal instance, run the following
// in powershell:
// Get-StartApps powershell
static AUMID: &str = "Microsoft.AutoGenerated.{A49227EA-5AF0-D494-A3F1-0918A278ED71}";

fn main() -> Result<()> {
    // Setup the RSS feed reader
    let mut prev_feeds: HashSet<String> = HashSet::new();
    let client = SyndicationClient::new()?;

    loop {
        // Get available feeds
        client.SetRequestHeader(
            h!("User-Agent"),
            h!("Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)"),
        )?;

        match check_feed(&client) {
            Ok(new_feeds) => {
                for feed in new_feeds {
                    if !prev_feeds.contains(&feed) {
                        // New feed found
                        let now = Local::now();
                        println!("{} - {}", now.format("%Y-%m-%d %H:%M:%S"), feed);
                        notify(&feed).expect("Failed to send notification");
                        prev_feeds.insert(feed);
                    } else {
                        continue;
                    }
                    // Allow time for async toast creation to complete
                    thread::sleep(Duration::from_millis(500));
                }
            }
            Err(_e) => {
                println!("Check_feed failed. Retrying in 5 minutes")
            }
        };

        // Update the stdout to show program is not idle/hung
        println!("Sleeping for 5 minutes");
        // Only check every 5 minutes to avoid spamming the RSS feed
        thread::sleep(Duration::from_secs(300));
    }
}

fn check_feed(client: &SyndicationClient) -> Result<Vec<String>> {
    let uri = Uri::CreateUri(h!("https://rpilocator.com/feed"))?;
    let feed = client.RetrieveFeedAsync(&uri)?.get()?;
    let feed_items: IVector<SyndicationItem> = feed.Items()?;
    let mut output_strings: Vec<String> = Vec::new();
    for item in feed_items {
        output_strings.push(item.Title().ok().unwrap().Text().ok().unwrap().to_string());
    }
    Ok(output_strings)
}

fn notify(feed: &String) -> Result<()> {
    if feed.contains(SEARCH_STRING) {
        // New feed detects search string. Send toast notification
        let notification = {
            let toast_xml: XmlDocument =
                ToastNotificationManager::GetTemplateContent(ToastTemplateType::ToastText01)?;
            let text_node: IXmlNode = toast_xml.GetElementsByTagName(h!("text"))?.Item(0)?;
            let text: XmlText = toast_xml.CreateTextNode(&HSTRING::from(feed))?;
            text_node.AppendChild(&text)?;
            ToastNotification::CreateToastNotification(&toast_xml)?
        };

        // Send the toast notification
        ToastNotificationManager::GetDefault()?
            .CreateToastNotifierWithId(&HSTRING::from(AUMID))?
            .Show(&notification)?;
    }
    Ok(())
}
